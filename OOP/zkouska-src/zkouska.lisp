(defun make-testing-picture ()
  (let ((p (make-instance 'picture)))
    (set-items p (list (set-filledp (move (set-radius (make-instance 'circle) 20) 40 40) t)
                       (set-selectable-p (set-filledp (move (set-radius (make-instance 'circle) 20) 100 20) t) NIL)
                       (make-polygon '((100 100) (120 150) (150 150)) t t :black)))))

(defvar *testing*)
(setf *testing* (make-testing-picture))
(set-items *testing* (cons (set-items-selectable-p (move (make-testing-picture) 150 150) nil)
                      (cons (move (make-testing-picture) 150 0) (items *testing*))))

(defclass shape (mg-object)
  ((color :initform :black)
   (thickness :initform 1)
   (filledp :initform nil)
   (window :initform nil)
   (selectable-p :initform T :reader selectable-p)))

(defmethod set-selectable-p ((s shape) val)
  (unless (or (eq val T) (eq val NIL))
    (error "Invalid boolean value"))
  (setf (slot-value s 'selectable-p) val)
  s)

(defmethod mouse-down ((shape shape) button position)
  (send-event shape 'ev-mouse-down shape button position)
  (if (selectable-p shape)
      (send-event shape 'ev-selected shape button)))

(defclass picture (compound-shape)
  ((propagate-color-p :initform nil)
   (items-selectable-p :initform T :reader items-selectable-p)))

(defmethod set-items-selectable-p ((pic picture) val)
  (unless (or (eq val T) (eq val NIL))
    (error "Invalid boolean value"))
  (setf (slot-value pic 'items-selectable-p) val)
  pic)

(defmethod do-set-items ((p picture) items)
  (call-next-method)
  (when (propagate-color-p p)
    (send-to-items-set-color p (color p)))
  (send-to-items p #'add-event 'ev-mouse-down)
  (send-to-items p #'add-event 'ev-selected)
  items)

(defmethod ev-selected ((p picture) sender origin button)
  (if (items-selectable-p p)
      (send-event p 'ev-selected origin button)
    (send-event p 'ev-selected p button)))

(defmethod max-x ((circ circle))
  (+ (x (center circ)) (radius circ)))

(defmethod min-x ((circ circle))
  (- (x (center circ)) (radius circ)))

(defmethod max-y ((circ circle))
  (+ (y (center circ)) (radius circ)))

(defmethod min-y ((circ circle))
  (- (y (center circ)) (radius circ)))

(defmethod make-border ((cs circle))
  (let ((min-x (min-x cs))
        (max-x (max-x cs))
        (min-y (min-y cs))
        (max-y (max-y cs))
        (rect (make-instance 'polygon)))
    (set-items rect (list (make-point min-x min-y)
                          (make-point max-x min-y)
                          (make-point max-x max-y)
                          (make-point min-x max-y)))
    (set-color rect :RED)))

(defmethod min-x ((poly polygon))
  (apply #'min (mapcar #'x (items poly))))

(defmethod max-x ((poly polygon))
  (apply #'max (mapcar #'x (items poly))))

(defmethod min-y ((poly polygon))
  (apply #'min (mapcar #'y (items poly))))

(defmethod max-y ((poly polygon))
  (apply #'max (mapcar #'y (items poly))))

(defmethod make-border ((p polygon))
  (let ((rect (make-instance 'polygon))
        (min-x (min-x p))
        (max-x (max-x p))
        (min-y (min-y p))
        (max-y (max-y p)))
    (set-items rect (list (make-point min-x min-y)
                          (make-point max-x min-y)
                          (make-point max-x max-y)
                          (make-point min-x max-y)))
    (set-color rect :RED)))

(defmethod min-x ((pt point))
  (x pt))

(defmethod max-x ((pt point))
  (x pt))

(defmethod min-y ((pt point))
  (y pt))

(defmethod max-y ((pt point))
  (y pt))

(defmethod make-border ((pt point))
  (let ((rect (make-instance 'rectangle)))
    (set-items rect (list (make-point (min-x pt) (min-y pt))
                          (make-point (max-x pt) (min-y pt))
                          (make-point (max-x pt) (max-y pt))
                          (make-point (min-x pt) (max-y pt))))
    (set-color rect :RED)))

(defmethod min-x ((pic picture))
  (if (= (length (items pic)) 1)
      (min-x (car (items pic)))
    (let ((tmpmin (min-x (car (items pic)))))
      (dolist (tmp (cdr (items pic)))
        (if (< (min-x tmp) tmpmin)
            (setf tmpmin (min-x tmp))))
      tmpmin)))

(defmethod max-x ((pic picture))
  (if (= (length (items pic)) 1)
      (max-x (car (items pic)))
    (let ((tmpmax (max-x (car (items pic)))))
      (dolist (tmp (cdr (items pic)))
        (if (> (max-x tmp) tmpmax)
            (setf tmpmax (max-x tmp))))
      tmpmax)))

(defmethod min-y ((pic picture))
  (if (= (length (items pic)) 1)
      (min-y (car (items pic)))
    (let ((tmpmin (min-y (car (items pic)))))
      (dolist (tmp (cdr (items pic)))
        (if (< (min-y tmp) tmpmin)
            (setf tmpmin (min-y tmp))))
      tmpmin)))

(defmethod max-y ((pic picture))
  (if (= (length (items pic)) 1)
      (max-y (car (items pic)))
    (let ((tmpmax (max-y (car (items pic)))))
      (dolist (tmp (cdr (items pic)))
        (if (> (max-y tmp) tmpmax)
            (setf tmpmax (max-y tmp))))
      tmpmax)))

(defmethod make-border ((pic picture))
    (let ((rect (make-instance 'polygon)))
      (set-items rect (list (make-point (min-x pic) (min-y pic))
                            (make-point (max-x pic) (min-y pic))
                            (make-point (max-x pic) (max-y pic))
                            (make-point (min-x pic) (max-y pic))))
      (set-color rect :RED))) 


(defclass border-win (window)
  ((border-slot :initform NIL :reader border)))

(defmethod set-border ((bw border-win) rect)
  (setf (slot-value bw 'border-slot) rect)
  (invalidate bw))

(defmethod reset-border ((bw border-win))
  (setf (slot-value bw 'border-slot) nil)
  (invalidate bw))

(defmethod set-shape ((bw border-win) shape)
  (call-next-method)
  (add-event shape 'ev-selected))

(defmethod border-contains ((bw border-win) item)
  (find item (border bw)))

(defmethod filter-border ((bw border-win) item)
  (let ((result nil))
    (dolist (x (border bw))
      (unless (eql x item)
        (setf result (cons x result))))
    (set-border bw result)))

(defmethod select ((bw border-win) origin)
  (set-border bw (cons origin nil)))

(defmethod multiselect ((bw border-win) origin)
  (if (border-contains bw origin)
      (filter-border bw origin)
  (set-border bw (cons origin (border bw)))))

(defmethod ev-selected ((bw border-win) sender origin button)
  (if (eql button :RIGHT)
      (multiselect bw origin)
    (select bw origin)))

(defmethod window-mouse-down ((bw border-win) button position)
  (if (contains-point-p (shape bw) position)
    (mouse-down (shape bw) button position)
    (reset-border bw)))

(defmethod set-window ((shape shape) value) 
  (setf (slot-value shape 'window) value)
  shape)

(defmethod redraw ((bw border-win))
  (let ((mgw (slot-value bw 'mg-window)))
    (mg:set-param mgw :background (background bw))
    (mg:clear mgw)
    (draw (shape bw))
    (if (border bw)
        (dolist (x (border bw))
          (draw (set-window (make-border x) bw)))))
  bw)
                 

(defvar *mywin*)
(setf *mywin* (make-instance 'border-win))
(set-shape *mywin* *testing*)